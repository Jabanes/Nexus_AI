<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nexus Diagnostic Client</title>
    <style>
        body { font-family: monospace; background: #111; color: #eee; padding: 2rem; }
        .card { background: #222; padding: 1.5rem; border-radius: 8px; margin-bottom: 1rem; border: 1px solid #333; }
        h1, h2 { margin-top: 0; }
        button { padding: 10px 20px; cursor: pointer; font-weight: bold; margin-right: 10px; }
        .green { background: #0f0; color: #000; border: none; }
        .red { background: #f00; color: #fff; border: none; }
        input, select { padding: 8px; background: #333; color: #fff; border: 1px solid #555; width: 100%; box-sizing: border-box; margin-bottom: 10px; }
        
        /* Meters */
        .meter-container { display: flex; align-items: center; margin: 10px 0; }
        .meter-label { width: 100px; }
        .meter-bar-bg { flex-grow: 1; height: 10px; background: #333; border-radius: 5px; overflow: hidden; }
        .meter-bar-fill { height: 100%; width: 0%; transition: width 0.1s; }
        #mic-fill { background: #0cf; }
        #spk-fill { background: #f0c; }

        #logs { height: 300px; overflow-y: auto; background: #000; border: 1px solid #444; padding: 10px; font-size: 12px; }
        .log-rx { color: #0f0; }
        .log-tx { color: #0cf; }
        .log-err { color: #f00; }
        .log-info { color: #ff0; }
    </style>
</head>
<body>
    <div class="card">
        <h1>üéôÔ∏è Nexus Diagnostic Client</h1>
        <label>Tenant ID</label>
        <select id="tenantSelect"><option value="barber_shop_demo">barber_shop_demo</option></select>
        
        <label>Status: <span id="status">Disconnected</span></label>
        
        <div class="meter-container">
            <span class="meter-label">üé§ Mic</span>
            <div class="meter-bar-bg"><div id="mic-fill" class="meter-bar-fill"></div></div>
        </div>
        <div class="meter-container">
            <span class="meter-label">üîä Speaker</span>
            <div class="meter-bar-bg"><div id="spk-fill" class="meter-bar-fill"></div></div>
        </div>

        <div style="margin-top: 20px;">
            <button id="btnConnect" class="green" onclick="startCall()">Start Call</button>
            <button id="btnDisconnect" class="red" onclick="stopCall()" disabled>Stop</button>
        </div>
    </div>

    <div id="logs"></div>

    <script>
        // --- CONFIG ---
        const SAMPLE_RATE = 24000; // Must match Server Output
        
        // --- STATE ---
        let ws = null;
        let audioCtx = null;
        let nextTime = 0;
        let mediaStream = null;
        let recorder = null;

        // --- UI ---
        const logDiv = document.getElementById('logs');
        const micFill = document.getElementById('mic-fill');
        const spkFill = document.getElementById('spk-fill');

        function log(msg, type = 'info') {
            const el = document.createElement('div');
            el.className = `log-${type}`;
            el.innerText = `[${new Date().toLocaleTimeString()}] ${msg}`;
            logDiv.appendChild(el);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        async function startCall() {
            // 1. Setup Audio Context (Must be user triggered)
            audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SAMPLE_RATE });
            log(`AudioContext created. State: ${audioCtx.state}`, 'info');
            
            // Resume if suspended (Browser Policy)
            if (audioCtx.state === 'suspended') {
                await audioCtx.resume();
                log(`AudioContext resumed. New State: ${audioCtx.state}`, 'info');
            }

            // 2. Setup WebSocket
            const tenant = document.getElementById('tenantSelect').value;
            const wsUrl = `ws://localhost:8000/ws/call/${tenant}?customer_phone=test`;
            
            ws = new WebSocket(wsUrl);
            ws.binaryType = 'arraybuffer';

            ws.onopen = () => {
                document.getElementById('status').innerText = 'Connected';
                document.getElementById('btnConnect').disabled = true;
                document.getElementById('btnDisconnect').disabled = false;
                log('WS Connected', 'info');
                startMic();
            };

            ws.onmessage = async (event) => {
                if (event.data instanceof ArrayBuffer) {
                    // AUDIO RECEIVED
                    playPcm(event.data);
                    visualizeSpeaker();
                } else {
                    // TEXT RECEIVED
                    log(`MSG: ${event.data}`, 'rx');
                }
            };

            ws.onclose = () => stopCall();
            ws.onerror = (e) => log('WS Error', 'err');
        }

        async function startMic() {
            try {
                mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                // Visualization
                const micCtx = new AudioContext();
                const source = micCtx.createMediaStreamSource(mediaStream);
                const analyser = micCtx.createAnalyser();
                source.connect(analyser);
                visualizeMic(analyser);

                // Recording (Send as WebM/Opus)
                recorder = new MediaRecorder(mediaStream, { mimeType: 'audio/webm;codecs=opus' });
                
                recorder.ondataavailable = (e) => {
                    if (e.data.size > 0 && ws && ws.readyState === 1) {
                        ws.send(e.data); // Send to Server
                    }
                };
                
                recorder.start(100); // 100ms chunks
                log('Microphone started', 'info');

            } catch (e) {
                log(`Mic Error: ${e.message}`, 'err');
            }
        }

        function playPcm(arrayBuffer) {
            // Convert s16le -> float32
            const int16 = new Int16Array(arrayBuffer);
            const float32 = new Float32Array(int16.length);
            for(let i=0; i<int16.length; i++) float32[i] = int16[i] / 32768;

            // Schedule
            const buffer = audioCtx.createBuffer(1, float32.length, SAMPLE_RATE);
            buffer.copyToChannel(float32, 0);
            
            const source = audioCtx.createBufferSource();
            source.buffer = buffer;
            source.connect(audioCtx.destination);
            
            const now = audioCtx.currentTime;
            nextTime = Math.max(now, nextTime);
            source.start(nextTime);
            nextTime += buffer.duration;
        }

        function stopCall() {
            if(ws) ws.close();
            if(recorder) recorder.stop();
            if(mediaStream) mediaStream.getTracks().forEach(t => t.stop());
            if(audioCtx) audioCtx.close();
            
            document.getElementById('status').innerText = 'Disconnected';
            document.getElementById('btnConnect').disabled = false;
            document.getElementById('btnDisconnect').disabled = true;
            log('Call Ended', 'info');
        }

        // --- VISUALIZERS ---
        function visualizeMic(analyser) {
            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            function draw() {
                if(!mediaStream || !mediaStream.active) return;
                requestAnimationFrame(draw);
                analyser.getByteFrequencyData(dataArray);
                const vol = dataArray.reduce((a,b)=>a+b) / dataArray.length;
                micFill.style.width = (vol * 2) + '%';
            }
            draw();
        }

        function visualizeSpeaker() {
            // Fake visualizer for incoming packets
            spkFill.style.width = '100%';
            setTimeout(() => spkFill.style.width = '0%', 100);
        }
    </script>
</body>
</html>